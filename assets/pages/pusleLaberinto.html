<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>cumplea√±os Ailyn</title>

<style>

:root{
    --rosa:#ff69b4;
    --rosa-osc:#e75a9f;
    --azul:#2196f3;
    --azul-osc:#1976d2;

    --fondo:#f7fbff;
    --fondo-card: rgba(255,255,255,0.65);

    --shadow:0 4px 16px rgba(255,120,170,0.18);
    --shadow-btn:0 6px 16px rgba(0,0,0,0.12);

    font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto;
}

html,body{
    margin:0;
    padding:0;
    background:var(--fondo);
    -webkit-tap-highlight-color: transparent;
}

/* CONTENEDOR PRINCIPAL */
.app{
    min-height:100vh;
    display:flex;
    justify-content:center;
    align-items:flex-start;
    padding:20px 10px;
}

/* TARJETA */
.card{
    background-image: url('../img/banCelebration.png');
    background-size: cover;
    background-position:center;
    width: 95%;
    max-width: 440px;
    padding:20px 10px 30px;
    border-radius:22px;
    box-shadow:var(--shadow);
    animation: fadeIn 1s ease-out;
    text-align:center;
    backdrop-filter: blur(6px);
}

@keyframes fadeIn{
    from{opacity:0; transform: translateY(10px);}
    to{opacity:1; transform: translateY(0);}
}

h1{
    margin:15px 0;
    font-size:1.4rem;
    color:var(--rosa-osc);
    text-shadow:0 2px 6px rgba(255,105,180,0.25);
}

/* CAJA CANVAS */
.canvas-box{
    width:100%;
    padding:8px;
    border-radius:16px;
    background:var(--fondo-card);
    box-shadow:var(--shadow);
    margin-top:8px;
}

canvas{
    width:100%;
    height:auto;
    display:block;
    border-radius:12px;
    background:transparent;
    touch-action:none;
}

/* CONTROLES */
.controls{
    margin-top:18px;
    display:flex;
    justify-content:center;
}

.ctrl-grid{
    display:grid;
    grid-template-columns:repeat(3,67px);
    gap:10px;
}

.ctrl-btn{
    width:67px;
    height:67px;
    border-radius:16px;
    background:white;
    border:none;
    font-size:24px;
    font-weight:700;
    color:var(--azul-osc);
    box-shadow:var(--shadow-btn);
    display:flex;
    justify-content:center;
    align-items:center;
    cursor:pointer;
    transition:0.2s;
}

.ctrl-btn:active{
    transform:scale(0.92);
    background:var(--azul);
    color:white;
}

/* TEXTO INFO */
.info{
    margin-top:10px;
    font-size:15px;
    color:#555;
}

/* OVERLAY FINAL */
.overlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.45);
    display:none;
    justify-content:center;
    align-items:center;
    padding:18px;
    z-index:1000;
}

.overlay.show{
    display:flex;
}

.cele{
    background:white;
    width:90%;
    max-width:380px;
    padding:20px;
    border-radius:20px;
    text-align:center;
    box-shadow:0 8px 30px rgba(0,0,0,0.25);
}

.cele img{
    width:70%;
    max-width:210px;
}

.cele h2{
    color:var(--rosa);
    margin:10px 0 8px;
    font-size:1.5rem;
}

.cele p{
    color:#555;
    margin-bottom:14px;
}

/* BOT√ìN SIGUIENTE */
.btn-primary{
    background:linear-gradient(135deg, var(--azul), var(--azul-osc));
    color:white;
    border:none;
    padding:14px 28px;
    font-size:17px;
    border-radius:14px;
    cursor:pointer;
    box-shadow:0 6px 14px rgba(33,150,243,0.4);
    transition:0.2s;
}

.btn-primary:active{
    transform:scale(0.92);
}

@media (max-width:450px){
    .ctrl-grid{
        grid-template-columns:repeat(3,60px);
        gap:8px;
    }
    .ctrl-btn{
        width:60px;
        height:60px;
        font-size:22px;
    }
}

</style>
</head>

<body>
<div class="app">
    <div class="card">

        <h1>Ayuda a Ailyn a encontrar la capibara</h1>

        <div class="canvas-box" id="canvasBox">
            <canvas id="maze" width="800" height="800"></canvas>
        </div>

        <div class="controls">
            <div class="ctrl-grid">
                <div></div>
                <div class="ctrl-btn" id="btn-up">‚Üë</div>
                <div></div>

                <div class="ctrl-btn" id="btn-left">‚Üê</div>
                <div class="ctrl-btn" id="btn-down">‚Üì</div>
                <div class="ctrl-btn" id="btn-right">‚Üí</div>
            </div>
        </div>
        <br><br>
        <div class="info">Usa los botones para mover</div>

    </div>
</div>

<!-- Overlay de victoria -->
<div class="overlay" id="overlay">
    <div class="cele">
        <h2>¬°Lo lograste..! üéâ</h2>
        <p>Si llegaste hasta aqu√≠‚Ä¶ dale siguiente para una sorpresa ‚ú®</p>
        <img src="../img/AilynCapibara.png">
        <br>
        <a href="./Invitacion.html">
            <button class="btn-primary">Siguiente</button>
        </a>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

<!-- Mantengo TU SCRIPT original sin alterarlo -->
<script>
(function(){
    // CONFIG
    const CHAR_SRC = '../img/AilynRun.png'; // imagen ni√±a (confirmada)
    const GOAL_IMG = '../img/capi-3.png'; // capibara (confirmada)
    const COLS = 20;
    const ROWS = 20;
    const canvas = document.getElementById('maze');
    const ctx = canvas.getContext('2d');

    // adapt canvas inner drawing size to square
    const size = Math.min(canvas.width, canvas.height);
    canvas.width = size;
    canvas.height = size;

    // compute cell size
    const cell = Math.floor(size / COLS);

    // A simple 20x20 maze map (0=path,1=wall,2=goal) - handcrafted for playability
    // You can replace this map by any other 20x20 array of 0/1/2.
    // Note: rows length must be ROWS and each row length COLS.
    const map = [
      // 20 columns per row
      [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1],
      [1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,0,1],
      [1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1],
      [1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,1,0,1],
      [1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,0,1,0,1],
      [1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,2],
      [1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1],
      [1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,0,1,0,1],
      [1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,1],
      [1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,1],
      [1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1],
      [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1],
      [1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1],
      [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1],
      [1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,1],
      [1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1],
      [1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,1],
      [1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0,1]
    ];

    // Find start = first 0 from top-left scanning, and goal (value 2)
    let start = {x:0,y:0};
    outer: for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(map[r][c]===0){ start={x:c,y:r}; break outer; }
      }
    }
    let goal = {x:COLS-1,y:ROWS-1};
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        if(map[r][c]===2){ goal={x:c,y:r}; break; }
      }
    }

    // player state
    let player = { x: start.x, y: start.y };
    let facing = 1; // 1 right, -1 left

    // load images
    const img = new Image();
    img.src = CHAR_SRC;
    let imgLoaded = false;
    img.onload = ()=> { imgLoaded = true; draw(); };

    const capy = new Image();
    capy.src = GOAL_IMG;
    let capyLoaded = false;
    capy.onload = ()=> { capyLoaded = true; draw(); };

    // draw functions
    function drawGrid(){
      ctx.clearRect(0,0,size,size);
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const x = c*cell, y = r*cell;
          const v = map[r][c];
          if(v===1){
            ctx.fillStyle = varColor('--wall','#2b2f36');
            ctx.fillRect(x,y,cell,cell);
          } else if(v===2){
            ctx.fillStyle = varColor('--goal','#a6e7a6');
            ctx.fillRect(x,y,cell,cell);
          } else {
            ctx.fillStyle = varColor('--path','#ffffff');
            ctx.fillRect(x,y,cell,cell);
          }
          ctx.strokeStyle = 'rgba(0,0,0,0.04)';
          ctx.strokeRect(x,y,cell,cell);
        }
      }
    }

    function drawGoalImage(){
      if(capyLoaded){
        const px = goal.x*cell, py = goal.y*cell;
        const padding = Math.max(2, Math.floor(cell*0.06));
        const sizeImg = cell - padding*2;
        ctx.drawImage(capy, px+padding, py+padding, sizeImg, sizeImg);
      }
    }

    function drawPlayer() {
  const px = player.x * cell;
  const py = player.y * cell;
  const padding = Math.floor(cell * 0.10);
  const sizeImg = cell - padding * 2;

  ctx.save(); // seguridad

  if (imgLoaded) {
    if (facing < 0) {
      // invertir horizontalmente
      ctx.translate(px + cell, py);
      ctx.scale(-1, 1);
      ctx.drawImage(img, padding, padding, sizeImg, sizeImg);
    } else {
      ctx.drawImage(img, px + padding, py + padding, sizeImg, sizeImg);
    }
  } else {
    ctx.fillStyle = "#ff6b6b";
    ctx.beginPath();
    ctx.arc(px + cell/2, py + cell/2, cell/3, 0, Math.PI*2);
    ctx.fill();
  }

  ctx.restore(); // RESTAURA SIEMPRE
}

    function draw(){
      drawGrid();
      drawGoalImage();
      drawPlayer();
    }

    // helpers
    function varColor(name, fallback){
      try {
        return getComputedStyle(document.documentElement).getPropertyValue(name) || fallback;
      } catch(e) { return fallback; }
    }

    function canMoveTo(nx, ny){
      if(nx<0||ny<0||nx>=COLS||ny>=ROWS) return false;
      return map[ny][nx] !== 1;
    }

    function move(dx, dy){
      const nx = player.x + dx, ny = player.y + dy;
      if(canMoveTo(nx,ny)){
        player.x = nx; player.y = ny;
        if(dx>0) facing=1; if(dx<0) facing=-1;
        draw();
        checkGoal();
      } else {
        // optional small shake animation: flash cell
        flashCell(player.x, player.y);
      }
    }

    function flashCell(cx, cy){
      const x = cx*cell, y = cy*cell;
      ctx.save();
      ctx.fillStyle = 'rgba(255,100,100,0.12)';
      ctx.fillRect(x,y,cell,cell);
      setTimeout(()=> draw(), 160);
      ctx.restore();
    }

    function checkGoal(){
      if(player.x===goal.x && player.y===goal.y){
        onWin();
      }
    }

    // controls (keyboard + touch buttons)
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'ArrowLeft') move(-1,0);
      if(e.key === 'ArrowRight') move(1,0);
      if(e.key === 'ArrowUp') move(0,-1);
      if(e.key === 'ArrowDown') move(0,1);
    });

    document.getElementById('btn-up').addEventListener('click', ()=> move(0,-1));
    document.getElementById('btn-left').addEventListener('click', ()=> move(-1,0));
    document.getElementById('btn-down').addEventListener('click', ()=> move(0,1));
    document.getElementById('btn-right').addEventListener('click', ()=> move(1,0));

    // reset and auto-solver
    document.getElementById('reset')?.addEventListener('click', ()=> {
      player.x = start.x; player.y = start.y; draw();
    });

    // simple BFS solver used by auto-resolve if you add a button later
    function bfsPath(from, to){
      const q = [];
      const visited = Array.from({length:ROWS}, ()=> Array(COLS).fill(false));
      const parent = Array.from({length:ROWS}, ()=> Array(COLS).fill(null));
      q.push(from);
      visited[from.y][from.x] = true;
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      while(q.length){
        const cur = q.shift();
        if(cur.x === to.x && cur.y === to.y){
          const p = [];
          let node = cur;
          while(node){
            p.push({x:node.x,y:node.y});
            node = parent[node.y][node.x];
          }
          p.reverse();
          return p;
        }
        for(const d of dirs){
          const nx = cur.x + d[0], ny = cur.y + d[1];
          if(nx<0||ny<0||nx>=COLS||ny>=ROWS) continue;
          if(visited[ny][nx]) continue;
          if(map[ny][nx]===1) continue;
          visited[ny][nx] = true;
          parent[ny][nx] = cur;
          q.push({x:nx,y:ny});
        }
      }
      return null;
    }

    // WIN handling: confetti + overlay + Next button
    const overlay = document.getElementById('overlay');
    const nextBtn = document.getElementById('nextBtn');

    function onWin(){
      // play confetti for 2s
      const duration = 2000;
      const end = Date.now() + duration;
      (function frame(){
        confetti({
          particleCount: 6,
          startVelocity: 20,
          spread: 55,
          origin: { x: Math.random()*0.6 + 0.2, y: 0 }
        });
        if(Date.now() < end) requestAnimationFrame(frame);
      })();

      // show overlay after short delay for dramatic effect
      setTimeout(()=> {
        overlay.classList.add('show');
      }, 350);
    }

    nextBtn.addEventListener('click', ()=> {
      // Aqu√≠ defines el comportamiento del bot√≥n Siguiente.
      // Por ahora hacemos una redirecci√≥n simulada o puedes llamar a la funci√≥n que cargue el siguiente juego.
      // window.location.href = 'juego_siguiente.html';
      window.location.href = "./invitacion.html"; // Reemplaza con la URL deseada
      overlay.classList.remove('show');
      // opcional: reiniciar jugador para jugar de nuevo
      player.x = start.x; player.y = start.y; draw();
    });

    // initial draw
    draw();

    // make canvas size responsive to container width while keeping square
    function resizeCanvas(){
      const box = document.getElementById('canvasBox');
      const w = Math.min(box.clientWidth - 20, 800);
      canvas.style.width = w + 'px';
      canvas.style.height = w + 'px';
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

  })();

</script>

</body>
</html>







